a.按开始时间自然排序
b.是否需要堆，存放结束时间，并按照结束时间自然排序 [代表上一场会议室]
loop都是从1开始
c. 解决问题的关键
       当前场会议的开始时间 > 上场会议的结束时间
            [i][0]         >    [i-1][1]
当前场会议的开始时间 > 上场会议的结束时间
    则，两场会议都能参加且不用新增会议室

问题1：会议室1 能否参加所有会议室 ？
       定义不能参加的情况 当前场会议的开始时间 < 上场会议的结束时间 即 [i][0] < [i-1][1]。则 return F
问题2：会议室II 最少使用的会议会数量 ？
       定义不用新增会议室的情况 当前场会议的开始时间 > 上场会议的结束时间 即[i][0] > heap.peek()
       则 删堆顶，将当前场会议结束时间加入堆 ；如果用新增会议室，则时间把当前会议室的结束时间加入堆
